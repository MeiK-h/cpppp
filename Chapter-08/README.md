# Chapter 8 函数探幽

## 目录
* [8.2.1: 创建引用变量](#创建引用变量)
* [8.2.3: 将引用用作函数参数](#将引用用作函数参数)
* [8.2.4: 将引用用作函数返回值](#将引用用作函数返回值)
* [8.2.6: 对象、继承和引用](#对象、继承和引用)
* [8.2.7: 何时使用引用参数](#何时使用引用参数)
* [8.4: 函数重载](#函数重载)
* [8.5: 函数模板](#函数模板)
* [8.5.5 编译器选择函数版本](#编译器选择函数版本)
* [编程练习](problem/)


### 创建引用变量

```C++
int a;
int & b = a;
```
可以创建一个 a 的别名 b，b 与 a 指向同一地址，必须在创建时初始化。


### 将引用用作函数参数

函数传参时，若参数数据比较大（结构体或者类），为防止进行大量的复制，可以使用按引用传递参数。为防止误修改，应采用 const * 常量引用。

如果函数实参与 const 常量引用参数不匹配，C++将生成临时变量，包括下面两种情况：
- 实参的类型正确，但不是左值
- 实参的类型不正确，但可以被转换为正确的类型

左值参数是可以被引用的数据对象，例如：变量、数组元素、结构体成员、引用和解除引用的指针；非左值包括字面常量和包含多项的表达式。

也就是说，如果函数参数为引用类型，那么调用时的参数必须严格相同（而不能存在自动类型转换和表达式计算），而当函数参数为 const & 常量引用类型时，调用时的参数可以为可转换的其他类型或者表达式，在调用时，会先创建一个只在函数调用期间存在的临时变量，用以储存计算后的值。


### 将引用用作函数返回值

通过将函数的返回类型设置为引用类型，可以实现很多奇妙的用法。

调用函数时，这条语句指向引用的内存，可以被修改和赋值，可以通过 const 限定不能修改。


### 对象、继承和引用

基类引用可以指向派生类对象


### 何时使用引用参数

对于不修改传递的参数的函数
- 若为基本类型或小的结构体，则按值传递
- 若传递对象为数组，则只能传递指针
- 若为较大的结构体，则使用 const 指针或 const 引用
- 对于类对象，使用 const 引用

对于修改的函数：
- 如果为基本类型，则使用指针
- 若为数组，则只能使用指针
- 结构体使用指针或者引用
- 类对象使用引用

当然，以上只是一些指导原则，很可能有充分的理由作出其他的选择。例如，对于基本类型， cin 使用引用，因此可以使用 cin >> n，而不是 cin >> &n。


### 函数重载

函数重载时，func(double &a), func(double &&a), func(const double &a) 对应三种不同的参数，分别为左值、右值、 const 来匹配。

若未定义右值的函数，则会匹配到 const double &。


### 函数模板

[8-5.cpp](8-5.cpp)

#### 显式具体化

编译器在匹配函数的时候顺序为：非模板函数 > 显式具体化 > 常规函数模板

通过 template<> 类型函数名<显式类型>(参数列表) 可以定义显式具体化函数

#### 实例化和具体化

[8-5-4.cpp](8-5-4.cpp)

不能同时（在一个文件或转换单元中）存在同类型的显式具体化和实例化


### 编译器选择函数版本

编译器在选择使用函数时，从最佳到最差的顺序如下：
1. 完全匹配，但是常规函数优先于模板。
2. 提升转换（例如， char 和 shorts 自动转换为 int ， float 自动转换为 double ）。
3. 标准转换（例如， int 转换为 char， long 转换为 double ）。
4. 用户定义的转换，如类声明中定义的转换。